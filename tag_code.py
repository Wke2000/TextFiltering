# -*- coding: utf-8 -*-
"""tag_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19WfrknBrS5haaf9f4Vplh331qe1wLS_U

# **Step 1**
"""

!pip install pandas

!pip install pandas openpyxl

import CODE
import pandas as pd
import openpyxl

# df = pd.read_excel('/content/tag respiration 230917.xlsx')

#This is for finding the first level classification
CODE.result.to_excel('1st_classification.xlsx')

"""# **Step 2**"""

import os

folder_name = "folder"

# 如果文件夹不存在，则创建它
os.makedirs(folder_name, exist_ok=True)

#This is for extracting groups


original_workbook = openpyxl.load_workbook('/content/1st_classification.xlsx')
original_sheet = original_workbook.active

# Create new excel and dataframe
new_workbook = openpyxl.Workbook()
new_sheet = new_workbook.active

# Search for rows
for row in original_sheet.iter_rows(min_row=2, values_only=True):  # begin from the second row
    cell_value = row[1]  # Values for B

    # finding the information between <>
    if '<' in cell_value or '>' in cell_value:
        new_sheet.append(row)

# Save new dataframe
new_workbook.save('/content/folder/this is the file for groups.xlsx',)

# Close
original_workbook.close()
new_workbook.close()

"""---

# Step 3

Keep the information between <>
"""

#This is for extracting information in groups
import pandas as pd

# Read
file_path = '/content/folder/this is the file for groups.xlsx'  # 请替换成你的Excel文件路径
df = pd.read_excel(file_path)
df.columns = [
'A'
,
'0'
,
'1'
]

# Create new dataframe
# new_df = df[['B', 'C']]
new_df = df[['0', '1']]

# Extract Information
def extract_content(cell_value):
    start = cell_value.find('<')
    end = cell_value.find('>')
    if start != -1 and end != -1:
        return cell_value[start + 1:end]
    else:
        return ''

# 应用提取函数到每个单元格
new_df['0'] = new_df['0'].apply(extract_content)
new_df['1'] = new_df['1'].apply(extract_content)

# Save
new_file_path = '/content/folder/The elements in groups.xlsx'  # 请替换成你想保存的新文件路径
new_df.to_excel(new_file_path, index=False)

print("Thiis is the elements in the groups")

"""# Step 4"""

#This is for finding the tags in each group
import re
def custom_split(s):
    result = []
    buffer = ''
    in_angle_bracket = False
    in_curly_bracket = False

    for c in s:
        if c == '<':
            in_angle_bracket = True
        elif c == '>':
            in_angle_bracket = False
        elif c == '{':
            in_curly_bracket = True
        elif c == '}':
            in_curly_bracket = False

        buffer += c

        if c == ' ' and not (in_angle_bracket or in_curly_bracket):
            if buffer.strip():
                result.append(buffer.strip())
                buffer = ''

    if buffer.strip():
        result.append(buffer.strip())

    return result



def has_pattern(s):
    pattern = r'\d+_[^_]+_\d+'
    return bool(re.search(pattern, s))
def find_pattern(s):
    pattern = r'\d+_[^_]+_\d+'
    match = re.search(pattern, s)
    return match.group(0) if match else None

def patterns_equal(s1, s2):
    pattern1 = find_pattern(s1)
    pattern2 = find_pattern(s2)
    return pattern1 == pattern2

import pandas as pd
df = pd.read_excel('/content/folder/The elements in groups.xlsx')
#for i in df.index:
result=[]
for i in df.index:
    s2=str(df.iloc[i,1])
    s1=str(df.iloc[i,0])
    s1=custom_split(s1)
    s2=custom_split(s2)
    tmp_s1=[]
    tmp_s2=[]
    for i in s1:
        if(has_pattern(i)):
            tmp_s1.append(i)
    for j in s2:
        if(has_pattern(i)):
            tmp_s2.append(j)
    for p in tmp_s1:
        for q in tmp_s2:
            if(patterns_equal(p,q)):
                result.append([p,q])

result=pd.DataFrame(result)
result.to_excel('/content/folder/This is the tag information in groups.xlsx')

"""# Step 5"""

import pandas as pd


excel1_file = '/content/1st_classification.xlsx'
excel2_file = '/content/folder/This is the tag information in groups.xlsx'


df1 = pd.read_excel(excel1_file)
df2 = pd.read_excel(excel2_file)

# Combine
merged_df = pd.concat([df1, df2], ignore_index=True)

# Merged and save
merged_file = 'Final result.xlsx'
merged_df.to_excel(merged_file, index=False)

print(f'The merged result has been saved {merged_file}')

"""

---



---

"""

import pandas as pd

# 读取Excel表格
df = pd.read_excel('/content/Final result.xlsx')

# 创建一个空字典来存储以'nn'为后缀的词的数量
nn_counts = {}

# 遍历Excel表格的某一列，假设列名为'Words'，根据实际情况修改列名
for word in df[1]:
    # 检查词是否以'nn'为后缀
    if word.endswith('nn_1'): #change this for the things you want
        # 如果以'nn'为后缀，将其添加到字典中或增加计数
        nn_counts[word] = nn_counts.get(word, 0) + 1

# 计算以'nn'为后缀的词的总数量
total_nn_words = sum(nn_counts.values())

# 打印每个以'nn'为后缀的词及其数量
for word, count in nn_counts.items():
    print(f"{word}: {count}")

# 打印总数量
print(f"总共以'nn'为后缀的词的数量: {total_nn_words}")

import pandas as pd

# 假设df是你的DataFrame，[1]表示你要处理的列
# 以下是一个示例DataFrame，你需要替换成你的实际数据


# 对[1]列中的每一行提取后四位，并统计不同后缀的数量
suffix_count = {}
for index, value in df[1].items():
    suffix = str(value)[-4:]
    if suffix not in suffix_count:
        suffix_count[suffix] = []
    suffix_count[suffix].append(index)

# 打印出每种后缀对应的行
for suffix, rows in suffix_count.items():
    print(f'后缀 {suffix} 出现在行 {rows} 數量爲 {len(rows)}')

print('The numern of suffix is:', len(suffix_count))

